From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: q66 <q66@chimera-linux.org>
Date: Wed, 21 Feb 2024 22:45:30 +0100
Subject: [PATCH] sdlwindow: use a mutex instead of atomic shared_ptr

libc++ does not implement this yet, and these are one-off events
(not something to be run per frame) so it does not matter if it
is a little bit slower
---
 src/Backends/SDLBackend.cpp     | 40 +++++++++++++++++++++-------
 src/Backends/WaylandBackend.cpp | 24 ++++++++++++-----
 src/steamcompmgr.cpp            | 13 +++++++---
 src/wlserver.cpp                | 46 ++++++++++++++++++++++++---------
 4 files changed, 93 insertions(+), 30 deletions(-)

diff --git a/src/Backends/SDLBackend.cpp b/src/Backends/SDLBackend.cpp
index 2bb8fb0..02f0d0d 100644
--- a/src/Backends/SDLBackend.cpp
+++ b/src/Backends/SDLBackend.cpp
@@ -192,13 +192,14 @@ namespace gamescope
 		std::vector<const char *> m_pszInstanceExtensions;
 
 		std::thread m_SDLThread;
+		std::mutex m_pSharedMutex;
 		std::atomic<SDLInitState> m_eSDLInit = { SDLInitState::SDLInit_Waiting };
 
 		std::atomic<bool> m_bApplicationGrabbed = { false };
 		std::atomic<bool> m_bApplicationVisible = { false };
-		std::atomic<std::shared_ptr<INestedHints::CursorInfo>> m_pApplicationCursor;
-		std::atomic<std::shared_ptr<std::string>> m_pApplicationTitle;
-		std::atomic<std::shared_ptr<std::vector<uint32_t>>> m_pApplicationIcon;
+		std::shared_ptr<INestedHints::CursorInfo> m_pApplicationCursor;
+		std::shared_ptr<std::string> m_pApplicationTitle;
+		std::shared_ptr<std::vector<uint32_t>> m_pApplicationIcon;
 		SDL_Surface *m_pIconSurface = nullptr;
 		SDL_Surface *m_pCursorSurface = nullptr;
 		SDL_Cursor *m_pCursor = nullptr;
@@ -523,7 +524,10 @@ namespace gamescope
 
 	void CSDLBackend::SetCursorImage( std::shared_ptr<INestedHints::CursorInfo> info )
 	{
-		m_pApplicationCursor = info;
+		{
+			std::lock_guard<std::mutex> g{m_pSharedMutex};
+			m_pApplicationCursor = info;
+		}
 		PushUserEvent( GAMESCOPE_SDL_EVENT_CURSOR );
 	}
 	void CSDLBackend::SetRelativeMouseMode( bool bRelative )
@@ -538,12 +542,18 @@ namespace gamescope
 	}
 	void CSDLBackend::SetTitle( std::shared_ptr<std::string> szTitle )
 	{
-		m_pApplicationTitle = szTitle;
+		{
+			std::lock_guard<std::mutex> g{m_pSharedMutex};
+			m_pApplicationTitle = szTitle;
+		}
 		PushUserEvent( GAMESCOPE_SDL_EVENT_TITLE );
 	}
 	void CSDLBackend::SetIcon( std::shared_ptr<std::vector<uint32_t>> uIconPixels )
 	{
-		m_pApplicationIcon = uIconPixels;
+		{
+			std::lock_guard<std::mutex> g{m_pSharedMutex};
+			m_pApplicationIcon = uIconPixels;
+		}
 		PushUserEvent( GAMESCOPE_SDL_EVENT_ICON );
 	}
 
@@ -887,7 +897,11 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_TITLE ) )
 					{
-						std::shared_ptr<std::string> pAppTitle = m_pApplicationTitle;
+						std::shared_ptr<std::string> pAppTitle;
+						{
+							std::lock_guard<std::mutex> g{m_pSharedMutex};
+							pAppTitle = m_pApplicationTitle;
+						}
 
 						std::string szTitle = pAppTitle ? *pAppTitle : "gamescope";
 						if ( g_bGrabbed )
@@ -900,7 +914,11 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_ICON ) )
 					{
-						std::shared_ptr<std::vector<uint32_t>> pIcon = m_pApplicationIcon;
+						std::shared_ptr<std::vector<uint32_t>> pIcon;
+						{
+							std::lock_guard<std::mutex> g{m_pSharedMutex};
+							pIcon = m_pApplicationIcon;
+						}
 
 						if ( m_pIconSurface )
 						{
@@ -928,7 +946,11 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_CURSOR ) )
 					{
-						std::shared_ptr<INestedHints::CursorInfo> pCursorInfo = m_pApplicationCursor;
+						std::shared_ptr<INestedHints::CursorInfo> pCursorInfo;
+						{
+							std::lock_guard<std::mutex> g{m_pSharedMutex};
+							pCursorInfo = m_pApplicationCursor;
+						}
 
 						if ( m_pCursorSurface )
 						{
diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index 664ed0e..0e27427 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -532,7 +532,8 @@ namespace gamescope
         std::optional<wl_fixed_t> m_ofPendingCursorX;
         std::optional<wl_fixed_t> m_ofPendingCursorY;
 
-        std::atomic<std::shared_ptr<zwp_relative_pointer_v1>> m_pRelativePointer = nullptr;
+        std::mutex m_pRelativePointerMutex;
+        std::shared_ptr<zwp_relative_pointer_v1> m_pRelativePointer = nullptr;
         std::unordered_set<uint32_t> m_uScancodesHeld;
 
         void Wayland_Registry_Global( wl_registry *pRegistry, uint32_t uName, const char *pInterface, uint32_t uVersion );
@@ -2819,17 +2820,25 @@ namespace gamescope
 
     void CWaylandInputThread::SetRelativePointer( bool bRelative )
     {
-        if ( bRelative == !!m_pRelativePointer.load() )
-            return;
+        {
+            std::lock_guard<std::mutex> g{m_pRelativePointerMutex};
+            if ( bRelative == !!m_pRelativePointer )
+                return;
+        }
         // This constructors/destructors the display's mutex, so should be safe to do across threads.
         if ( !bRelative )
         {
+            std::lock_guard<std::mutex> g{m_pRelativePointerMutex};
             m_pRelativePointer = nullptr;
         }
         else
         {
             zwp_relative_pointer_v1 *pRelativePointer = zwp_relative_pointer_manager_v1_get_relative_pointer( m_pRelativePointerManager, m_pPointer );
-            m_pRelativePointer = std::shared_ptr<zwp_relative_pointer_v1>{ pRelativePointer, []( zwp_relative_pointer_v1 *pObject ){ zwp_relative_pointer_v1_destroy( pObject ); } };
+            auto relp = std::shared_ptr<zwp_relative_pointer_v1>{ pRelativePointer, []( zwp_relative_pointer_v1 *pObject ){ zwp_relative_pointer_v1_destroy( pObject ); } };
+            {
+                std::lock_guard<std::mutex> g{m_pRelativePointerMutex};
+                m_pRelativePointer = std::move(relp);
+            }
             zwp_relative_pointer_v1_add_listener( pRelativePointer, &s_RelativePointerListener, this );
         }
     }
@@ -3008,8 +3017,11 @@ namespace gamescope
     }
     void CWaylandInputThread::Wayland_Pointer_Motion( wl_pointer *pPointer, uint32_t uTime, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
     {
-        if ( m_pRelativePointer.load() != nullptr )
-            return;
+        {
+            std::lock_guard<std::mutex> g{m_pRelativePointerMutex};
+            if ( m_pRelativePointer != nullptr )
+                return;
+        }
 
         if ( !cv_wayland_mouse_warp_without_keyboard_focus && !m_bKeyboardEntered )
         {
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index c1d49fd..52c4ba3 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -143,7 +143,8 @@ std::atomic<uint32_t> g_unCurrentVRSceneAppId;
 gamescope_color_mgmt_tracker_t g_ColorMgmt{};
 
 static gamescope_color_mgmt_luts g_ColorMgmtLutsOverride[ EOTF_Count ];
-std::atomic<std::shared_ptr<lut3d_t>> g_ColorMgmtLooks[EOTF_Count];
+std::mutex m_pColorMutex;
+std::shared_ptr<lut3d_t> g_ColorMgmtLooks[EOTF_Count];
 
 
 gamescope_color_mgmt_luts g_ColorMgmtLuts[ EOTF_Count ];
@@ -775,7 +776,10 @@ bool set_color_shaperlut_override(const char *path)
 bool set_color_look_pq(const char *path)
 {
 	bool bRaisesBlackLevelFloor = false;
-	g_ColorMgmtLooks[EOTF_PQ] = LoadCubeLut( path, bRaisesBlackLevelFloor );
+	{
+		std::lock_guard<std::mutex> g{m_pColorMutex};
+		g_ColorMgmtLooks[EOTF_PQ] = LoadCubeLut( path, bRaisesBlackLevelFloor );
+	}
 	cv_overlay_unmultiplied_alpha = bRaisesBlackLevelFloor;
 	g_ColorMgmt.pending.externalDirtyCtr++;
 	return true;
@@ -784,7 +788,10 @@ bool set_color_look_pq(const char *path)
 bool set_color_look_g22(const char *path)
 {
 	bool bRaisesBlackLevelFloor = false;
-	g_ColorMgmtLooks[EOTF_Gamma22] = LoadCubeLut( path, bRaisesBlackLevelFloor );
+	{
+		std::lock_guard<std::mutex> g{m_pColorMutex};
+		g_ColorMgmtLooks[EOTF_Gamma22] = LoadCubeLut( path, bRaisesBlackLevelFloor );
+	}
 	cv_overlay_unmultiplied_alpha = bRaisesBlackLevelFloor;
 	g_ColorMgmt.pending.externalDirtyCtr++;
 	return true;
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 4d8546e..69dff3f 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1061,7 +1061,8 @@ static void gamescope_control_display_sleep( struct wl_client *client, struct wl
 }
 
 extern gamescope::ConVar<bool> cv_overlay_unmultiplied_alpha;
-extern std::atomic<std::shared_ptr<lut3d_t>> g_ColorMgmtLooks[EOTF_Count];
+extern std::mutex m_pColorMutex;
+extern std::shared_ptr<lut3d_t> g_ColorMgmtLooks[EOTF_Count];
 
 static gamescope::ConCommand cc_set_look("set_look", "Set a look for a specific EOTF. Eg. set_look mylook.cube (g22 only), set_look pq mylook.cube, set_look mylook_g22.cube mylook_pq.cube",
 []( std::span<std::string_view> args )
@@ -1070,7 +1071,10 @@ static gamescope::ConCommand cc_set_look("set_look", "Set a look for a specific
 	{
 		std::string arg1 = std::string{ args[1] };
 		bool bRaisesBlackLevelFloor = false;
-		g_ColorMgmtLooks[ EOTF_Gamma22 ] = LoadCubeLut( arg1.c_str(), bRaisesBlackLevelFloor );
+		{
+			std::lock_guard<std::mutex> g{m_pColorMutex};
+			g_ColorMgmtLooks[ EOTF_Gamma22 ] = LoadCubeLut( arg1.c_str(), bRaisesBlackLevelFloor );
+		}
 		cv_overlay_unmultiplied_alpha = bRaisesBlackLevelFloor;
 		g_ColorMgmt.pending.externalDirtyCtr++;
 		hasRepaint = true;
@@ -1082,11 +1086,17 @@ static gamescope::ConCommand cc_set_look("set_look", "Set a look for a specific
 		bool bRaisesBlackLevelFloor = false;
 		if ( args[1] == "g22" || args[1] == "G22")
 		{
-			g_ColorMgmtLooks[ EOTF_Gamma22 ] = LoadCubeLut( arg2.c_str(), bRaisesBlackLevelFloor );
+			{
+				std::lock_guard<std::mutex> g{m_pColorMutex};
+				g_ColorMgmtLooks[ EOTF_Gamma22 ] = LoadCubeLut( arg2.c_str(), bRaisesBlackLevelFloor );
+			}
 		}
 		else if ( args[1] == "pq" || args[1] == "PQ" )
 		{
-			g_ColorMgmtLooks[ EOTF_PQ ] = LoadCubeLut( arg2.c_str(), bRaisesBlackLevelFloor );
+			{
+				std::lock_guard<std::mutex> g{m_pColorMutex};
+				g_ColorMgmtLooks[ EOTF_PQ ] = LoadCubeLut( arg2.c_str(), bRaisesBlackLevelFloor );
+			}
 		}
 		else
 		{
@@ -1099,8 +1109,11 @@ static gamescope::ConCommand cc_set_look("set_look", "Set a look for a specific
 			pG22LUT = LoadCubeLut( arg1.c_str(), bRaisesBlackLevelFloor );
 			pPQLUT = LoadCubeLut( arg2.c_str(), bDummy );
 
-			g_ColorMgmtLooks[ EOTF_Gamma22 ] = pG22LUT;
-			g_ColorMgmtLooks[ EOTF_PQ ] = pPQLUT;
+			{
+				std::lock_guard<std::mutex> g{m_pColorMutex};
+				g_ColorMgmtLooks[ EOTF_Gamma22 ] = pG22LUT;
+				g_ColorMgmtLooks[ EOTF_PQ ] = pPQLUT;
+			}
 		}
 		cv_overlay_unmultiplied_alpha = bRaisesBlackLevelFloor;
 		g_ColorMgmt.pending.externalDirtyCtr++;
@@ -1109,8 +1122,11 @@ static gamescope::ConCommand cc_set_look("set_look", "Set a look for a specific
 	else
 	{
 		cv_overlay_unmultiplied_alpha = false;
-		g_ColorMgmtLooks[ EOTF_Gamma22 ] = nullptr;
-		g_ColorMgmtLooks[ EOTF_PQ ] = nullptr;
+		{
+			std::lock_guard<std::mutex> g{m_pColorMutex};
+			g_ColorMgmtLooks[ EOTF_Gamma22 ] = nullptr;
+			g_ColorMgmtLooks[ EOTF_PQ ] = nullptr;
+		}
 		g_ColorMgmt.pending.externalDirtyCtr++;
 		hasRepaint = true;
 	}
@@ -1158,8 +1174,11 @@ static void gamescope_control_set_look( struct wl_client *client, struct wl_reso
 	}
 
 	cv_overlay_unmultiplied_alpha = bRaisesBlackLevelFloor;
-	g_ColorMgmtLooks[ EOTF_Gamma22 ] = pG22LUT;
-	g_ColorMgmtLooks[ EOTF_PQ ] = pPQLUT;
+	{
+		std::lock_guard<std::mutex> g{m_pColorMutex};
+		g_ColorMgmtLooks[ EOTF_Gamma22 ] = pG22LUT;
+		g_ColorMgmtLooks[ EOTF_PQ ] = pPQLUT;
+	}
 	g_ColorMgmt.pending.externalDirtyCtr++;
 	hasRepaint = true;
 }
@@ -1167,8 +1186,11 @@ static void gamescope_control_set_look( struct wl_client *client, struct wl_reso
 static void gamescope_control_unset_look( struct wl_client *client, struct wl_resource *resource )
 {
 	cv_overlay_unmultiplied_alpha = false;
-	g_ColorMgmtLooks[ EOTF_Gamma22 ] = nullptr;
-	g_ColorMgmtLooks[ EOTF_PQ ] = nullptr;
+	{
+		std::lock_guard<std::mutex> g{m_pColorMutex};
+		g_ColorMgmtLooks[ EOTF_Gamma22 ] = nullptr;
+		g_ColorMgmtLooks[ EOTF_PQ ] = nullptr;
+	}
 	g_ColorMgmt.pending.externalDirtyCtr++;
 	hasRepaint = true;
 }
