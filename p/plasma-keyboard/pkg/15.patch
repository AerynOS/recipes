From e29243e204b50497c30edb75165f76562c20bb44 Mon Sep 17 00:00:00 2001
From: Devin Lin <espidev@gmail.com>
Date: Tue, 1 Jul 2025 21:38:38 -0400
Subject: [PATCH] Fix some issues with input event passing

This MR fixes several issues with InputThing and how it passes events to
the compositor.

I removed the listening of events from
QVirtualKeyboardInputEngine::virtualKeyClicked. We already get the key
events in InputThing through keyPressEvent/keyReleaseEvent, and so we
ended up with duplicate events. In keyPressEvent/keyReleaseEvent, the
call of `keysym` was incorrect, as it passed the Qt key enum, not the
xkbcommon keysym value to wayland. With this fixed, I dropped
`virtualKeyClicked` handling (where keysym was implemented properly, but
not for all keys). This fixes the backspace and shift keys not working
properly.

I added an IGNORED_KEYS list for key events to ignore, which fixes the
"special keys" button on the vkbd entering a strange character.

I fixed cursor positioning in `inputMethodEvent`. The
input_method_v1 protocol states that the preedit_cursor call must be
before preedit_string
(https://wayland.app/protocols/input-method-unstable-v1#zwp_input_method_context_v1:request:preedit_cursor). The order was flipped in the code, causing cursor
positioning to be off and delayed by a character.

I uncommented the line in `inputMethodQuery` that implements the "no
predictive text" flag. Text fields with that flag set now immediately
get committed characters without preediting (ex. qmlkonsole)

I added a missing null check in `keysym` that caused crashes if the
input method context was not initialized.

I also added differentiation for key press/release handling between
textual and non-textual buttons. text-input-v3 clients seem to not
handle when keys are entered through keysym, so we need to properly
commit text characters. This fixes text input not working in GTK and
Chromium.
---
 src/inputplugin.cpp |  3 +++
 src/main.cpp        | 60 +++++++++++++++++++++++++++++++--------------
 2 files changed, 44 insertions(+), 19 deletions(-)

diff --git a/src/inputplugin.cpp b/src/inputplugin.cpp
index 86fe513..7441aff 100644
--- a/src/inputplugin.cpp
+++ b/src/inputplugin.cpp
@@ -97,6 +97,9 @@ void InputPlugin::commit(const QString &text)
 
 void InputPlugin::keysym(uint timestamp, uint sym, KeyState state, uint modifiers)
 {
+    if (!m_context) {
+        return;
+    }
     m_context->keysym(m_context->m_latestSerial, timestamp, sym, state, modifiers);
 }
 
diff --git a/src/main.cpp b/src/main.cpp
index 313697e..7f3f88e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -20,6 +20,8 @@
 #include <QtWaylandClient/private/qwaylandwindow_p.h>
 #include <qpa/qwindowsysteminterface.h>
 
+#include <set>
+
 #include "inputmethod_p.h"
 #include "inputplugin.h"
 #include "qwaylandinputpanelshellintegration_p.h"
@@ -27,11 +29,16 @@
 
 Q_GLOBAL_STATIC(InputMethod, s_im)
 
+static const std::set<int> IGNORED_KEYS = {
+    Qt::Key_Context1 // Triggered by "special keys" button
+};
+
 class InputThing : public QQuickItem
 {
     Q_OBJECT
     // QML_ELEMENT
     Q_PROPERTY(QVirtualKeyboardInputEngine *engine WRITE setEngine)
+
 public:
     InputThing()
         : m_input(&(*s_im))
@@ -57,19 +64,7 @@ public:
     }
 
     void setEngine(QVirtualKeyboardInputEngine *engine) {
-        QObject::connect(engine, &QVirtualKeyboardInputEngine::virtualKeyClicked, this, [this] (Qt::Key key, const QString &text, Qt::KeyboardModifiers modifiers, bool isAutoRepeat) {
-            static const QHash<Qt::Key, xkb_keysym_t> qtKeyToXkb = {
-                { Qt::Key_Return, XKB_KEY_Return },
-                { Qt::Key_Space, XKB_KEY_space },
-                { Qt::Key_Tab, XKB_KEY_Tab },
-            };
-
-            auto it = qtKeyToXkb.constFind(key);
-            if (it != qtKeyToXkb.constEnd()) {
-                m_input.keysym(QDateTime::currentMSecsSinceEpoch(), *it, InputPlugin::Pressed, 0);
-                m_input.keysym(QDateTime::currentMSecsSinceEpoch(), *it, InputPlugin::Released, 0);
-            }
-        });
+        // TODO: hook into engine events if necessary?
     }
 
     QVariant inputMethodQuery(Qt::InputMethodQuery query) const override
@@ -91,7 +86,7 @@ public:
                 qtHints |= Qt::ImhSensitiveData;
             }
             if ((imHints & InputPlugin::content_hint_auto_completion) == 0) {
-                // qtHints |= Qt::ImhNoPredictiveText;
+                qtHints |= Qt::ImhNoPredictiveText;
             }
             if ((imHints & InputPlugin::content_hint_auto_correction) == 0 || (imHints & InputPlugin::content_hint_auto_capitalization) == 0) {
                 qtHints |= Qt::ImhNoAutoUppercase;
@@ -172,32 +167,59 @@ public:
         return {};
     }
 
-
     void keyPressEvent(QKeyEvent *event) override
     {
+        if (IGNORED_KEYS.find(event->key()) != IGNORED_KEYS.end()) {
+            return;
+        }
+
         QList<xkb_keysym_t> keys = QXkbCommon::toKeysym(event);
         for (auto key : keys) {
-            m_input.keysym(0, event->key(), InputPlugin::Pressed, 0);
+            // Simulate key press only if it's not textual
+            if (event->text().isEmpty() || key == XKB_KEY_Return) { // (return is technically "\n")
+                m_input.keysym(QDateTime::currentMSecsSinceEpoch(), key, InputPlugin::Pressed, 0);
+            }
         }
     }
 
     void keyReleaseEvent(QKeyEvent *event) override
     {
+        if (IGNORED_KEYS.find(event->key()) != IGNORED_KEYS.end()) {
+            return;
+        }
+
         QList<xkb_keysym_t> keys = QXkbCommon::toKeysym(event);
         for (auto key : keys) {
-            m_input.keysym(0, event->key(), InputPlugin::Released, 0);
+            if (event->text().isEmpty() || key == XKB_KEY_Return) { // (return is technically "\n")
+                // Simulate the keyboard press for non textual keys
+                m_input.keysym(QDateTime::currentMSecsSinceEpoch(), key, InputPlugin::Released, 0);
+            } else {
+                // If we have text coming as a key event, use it to commit the string
+                m_input.commit(event->text());
+            }
         }
     }
+
     void inputMethodEvent(QInputMethodEvent *event) override
     {
+        // Delete characters that are supposed to be replaced
+        if (event->replacementLength() > 0) {
+            m_input.deleteSurroundingText(event->replacementStart(), event->replacementLength());
+        }
+
         for (auto x : event->attributes()) {
             if (x.type == QInputMethodEvent::TextFormat) {
                 m_input.setPreEditStyle(x.start, x.length, x.value.value<QTextFormat>().type());
             }
         }
+
+        // Send cursor position (must be before predit string)
+        m_input.setPreEditCursor(event->preeditString().size());
+
+        // Send currently being edited string
         m_input.setPreEditString(event->preeditString());
-        m_input.setPreEditCursor(event->preeditString().size() + 1);
-        // m_input.setPreEditCursor(event->curso);
+
+        // Commit string if we have a finished string
         if (const auto commit = event->commitString(); !commit.isEmpty()) {
             m_input.commit(commit);
         }
-- 
GitLab

